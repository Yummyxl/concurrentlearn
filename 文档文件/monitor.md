+ jvm中的同步是基于进入于退出监视器对象（管程对象）（Monitor）来实现的，每个对象实例都会有一个Monitor对象，Monitor对象会随着java对象一同
创建和销毁
+ 当使用 synchronized 关键字来修饰代码块时候，字节码是用 monitorenter 和 monitorexit 指令来实现锁的获取和释放动作
+ 对于 synchronized 关键字来说，修饰方法并没有出现 monitorenter 和 monitorexit指令，而是出现了一个 ACC_SYNCHRONIZED flag标志,
原因是 jvm 使用了 ACC_SYNCHRONIZED 标志来区分一个方法是否问同步方法，当方法被调用时候，调用指令会检查该方法是否拥有 ACC_SYNCHRONIZED
标志，如果有，那么执行线程将会先持有方法所在对象的monitor锁，然后再去执行方法体，其他线程均无法获取对象的monitor锁，当线程执行完毕后，依然会释放掉
onitor对象，即便方法抛出异常，也会释放掉
+ synchronized 修饰静态方法时候，即方法标志有 ACC_STATIC, ACC_SYNCHRONIZED，这是一个静态同步方法，执行线程就会尝试获取 这个方法所在类class
对应的monitor锁
+ 当多个线程同时访问同一块代码时，这些线程会放到一个叫EntryList集合当中，处于阻塞状态下的线程会被放到该列表当中，接下来当对象获取到对象的Monitor
时，Monitor依赖于底层系统的 mutex lock 来实现互斥的，线程获取 mutex 成功，其他线程就无法获取到 mutex
+ 如果线程调用来wait方法，那么该线程就会释放掉锁持有的 mutex 并且该线程会进入到 WaitSet （等待集合）中，等待下一次其他线程调用 notify/notifyAll
方法唤醒。如果当前线程顺利执行完毕方法，那么它也会释放掉所持有的 mutex
+ 同步锁在这种实现方式当中，因为Monitor是依赖于底层的操作系统实现，这样就存在用户态和内核台之间的切换，所以会增加内存开销，通过对象互斥锁的概念
来保证共享数据操作的完整性，每个对象都对应于一个可成为《互斥锁》的标记，这个标记用于保证在任何时刻，只能有一个线程持有该对象。 当线程执行代码时是
处于用户态状态下，因为这是java应用程序，处于程序范畴之内，当线程尝试获取某个对象的锁，但是这个对象的锁已经被另外线程获取到没有被释放掉，那么这个线程
就会进入到阻塞的状态，因为Monitor是由底层的操作系统 mutex lock 来实现的，所以一旦线程进入到阻塞或者等待状态（调用了wait）就会立刻进入到内核态，
当线程又去尝试获取对象的锁并且能够成功获取到，该线程又会从内核态转入到用户态，比较消耗性能，和零拷贝都是一样的道理
+ 那些处于 EntryList 和 WaitSet 中的线程均处于阻塞状态，阻塞操作是由操作系统来完成的，在linux下是通过 pthread_mutex_lock函数来实现的，线程
被阻塞后变会进入到内核调度状态，这会导致系统在用户态于内核态之间来回切换，严重影响锁的性能，解决这个问题的办法就是 ***自旋***，其原理是 当发生对
Monitor的争用时，若 Owner 在很短的时间内能够完成锁的释放，则那些正在争用的线程就可以稍微等下（就是所谓的自旋，空转），在owner线程释放掉锁之后，
争用线程可能会立刻获取锁，从而避免了系统阻塞。不过当owner运行时间超过了临界值时，争用线程自旋一段时间后依然无法获取到锁，这时争用线程就停止自旋，
进入到阻塞状态，所以总体思想是，先自旋，不成功再进行阻塞，尽量降低阻塞的可能性，对那些执行时间很短的代码来说有极大的性能提升。显然，自旋在多核处理器
上才有意义。
+ 互斥锁的属性:
   - PTHREAD_MUTEX_TIMED_NP  这是缺省值，也就是普通锁。当一个线程加锁后，其他线程将会形成一个等待队列，并且在解锁后按照优先级获取到锁。这种
   策略可以确保资源分配的公平性。
   - PTHREAD_MUTEX_RECURSIVE_NP   嵌套锁，允许同一个线程对同一把锁成功获取多次，并通过unlock来解锁，如果是不同线程请求则在加锁的线程解锁时
   重新进行竞争。（可重入锁）
   - PTHREAD_MUTEX_ERRORCHECK_NP  检错锁， 如果一个线程请求同一个锁，则返回 EDEADLK,否则于 PTHREAD_MUTEX_TIMED_NP 类型动作相同，这样就确保
   了在不允许多次加锁的情况下最简单的死锁情况
   - PTHREAD_MUTEX_ADAPTIVE_NP 适用锁，动作最简单的类型，仅仅等待解锁后重新竞争
