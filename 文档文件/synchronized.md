+ 在JDK1.5之后，并发包引入了Lock锁，Lock锁是基于java来实现的，因此锁的获取和释放都是通过java来实现和控制的，然而，synchronized 是基于底层
操作系统的 mutex lock 来实现的，每次对于锁的获取和释放动作都会带来用户态和内核态之间的切换，这样会极大加重系统的负担，在并发量较高时，也就是
锁的竞争比较激烈时，synchronized 的锁性能上的表现比较差。

+ 从JDK1.6开始，synchronized 锁的实现发生了很大的变化，JVM引入了相应的优化手段来提升 synchronized 锁的性能，这些提升涉及 偏向锁、轻量级锁
和重量级锁，从而减少锁的竞争锁带来的用户态和内核态之间的切换（所有的优化出发点都是减少用户态和内核态切换，也就是阻塞的状态）；这种锁的优化实际
上是通过java对象头中的一些标记来实现的，对于锁的访问和改变，实际上都于java对象头息息相关。

+ 从JDK1.6开始，对象实例在堆当中会被划分为三个组成部分
   - 对象头，主要由三块内容来构成
      * mark word 
      * 指向类的指针
      * 数组长度（数组特有）
   - 实例数据
   - 对其填充  因为JVM要求java的对象占的内存大小应该是8bit的倍数，所以后面有几个字节用于把对象的大小补齐至8bit的倍数，没有特别的功能

+ 其中mark word 记录了对象、锁、垃圾收集相关的信息，在64位系统中是64位，主要包括如下信息
   - 无锁标记
   - 偏向锁标记
   - 轻量级锁标记
   - 重量级锁标记
   - GC标记

+ 对于 synchronized 锁来说，都是通过 mark word 中的锁标志位是否是偏向锁来达成的，synchronized 关键字锁对应的锁都是从偏向锁开始，锁竞争的
不断升级，逐步演化至轻量级锁，最后则变成重量级锁。

+ 对于锁的演化来说，锁的升级经历这些阶段， 无锁 -》 偏向锁 -》 轻量级锁 -》 重量级锁，可以通过设置启动参数来设置，比如设置不启动偏向锁。

+ 偏向锁： 针对于一个线程来说，当一个线程执行一个 synchronized 方法，执行完之后又去执行这个 synchronized，这时候一般情况下会尝试获取
这个对象的锁，在第一次访获取这个对象锁的时候，对象的 mark word 中的锁标设置偏向（其实锁标志位为无锁，然后是否偏向锁状态为是），并且记录了
线程的id，下次这个线程再来获取锁的时候，就会直接获取成功，不用再进行用户态到内核态切换转到操作系统的 mutex lock 来实现，极大提升性能。
主要作用是优化同一个线程多次获取一个锁的情况；如果一个synchronized方法被一个线程访问，那么这个方法所在对象就会在mark word中将偏向锁进行
标记，同时会有一个字段来存储线程id，当这个线程再次访问synchronized时候，会检查这个对象的mark word中的偏向锁标记是否是指向了访问线程id，
如果是那么该线程就无需进入管程（monitor）了，而是直接进入方法体。

+ 轻量级锁 如果是另外一个线程访获取到了对象的锁，这时候第二个线程又来获取对象的锁，由于该对象的锁已经被第一个线程获取，因此它是偏向锁，而第二个线程
在争抢时，会发现该对象的 mark word 已经是偏向锁，但在里边存储但id并不是自己（是第一个线程的id），那么它会进行 CAS （compare and swap）
从而获取到锁，分为两种情况：
   - 获取锁成功，那么会直接将对象 mark word 中的线程id由第一个变为自己的（还是偏向锁状态），这样该对象依然会保持偏向锁状态
   - 获取锁失败，那标示这时多个线程可能在争抢同一个对象的锁，那么这时偏向锁会升级，升级为轻量级锁

+ 自选锁 若自旋失败的话，那么锁就会转化为重量级锁，在这种情况下，无法获取到锁的线程进入到 monitor 中。自旋最大的一个特点是避免了线程从用户态切换到内核态

+ 重量级锁，锁状态的最终形态。线程最终从用户态进入到内核态。

+ 锁消除 编译器对锁的优化， JIT编译器（just in time）可以在动态变异代码时，使用一种叫 逃逸分析 的技术，通过该技术来判断程序中使用的对象的锁是不是只被一个线程
使用，而没有散步到其他线程中，如果情况是这样，那么JIT编译器在编译这个同步代码的时候就不会生成 synchronized 关键字锁标示的锁的申请和释放，从
而消除了锁的使用流程。

+ 锁粗化 JIT在执行动态编译时，如果发现前后相邻的 synchronized 代码块锁定的是同一个对象，那么会把这几个相邻的代码块合并为一个较大的同步快，
这样做的好处在于线程执行这些代码时，就无需频繁申请和释放锁了，达到申请和释放一次就可以执行完全部代码，从而提升了性能。